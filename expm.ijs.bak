NB. expm.ijs
NB. Calculate matrix exponent and its integral
NB. 
NB. pexpm  pre-calculate time-invariant parts for expm and iexpm
NB. expm   calculate matrix exponent via Lagrange-Sylvester
NB.        interpolation polynome
NB. iexpm  calculate integral of matrix exponent via Cauchy
NB.        identity
NB.
NB. 2008-01-10 1.0.0 Igor Zhuravlov

NB. ===========================================================================
NB. pexpm
NB. Pre-calculate time-invariant parts for expm and iexpm
NB.
NB. Usage:
NB.   'M P V'=. pexpm A
NB. where:
NB.   A - N-by-N state matrix of LTI system from SS representation
NB.   M - K-by-N matrix for equation M*A(t)=L(t)
NB.   P - N-by-N-by-N matrix, powers 0..(N-1) of A
NB.   V - N-vector, eigenvalies of A


NB. ===========================================================================
NB. expm
NB. Calculate matrix exponent exp(A*T) of matrix A for discretizing period T
NB. via Lagrange-Sylvester interpolation polynome
NB.
NB. Usage:
NB.   E=. expm M;P;V;T
NB. where:
NB.   M - K-by-N matrix for equation M*A(t)=L(t)
NB.   P - N-by-N-by-N matrix, powers 0..(N-1) of A
NB.   V - N-vector, eigenvalies of A
NB.   T - sampling period, T>0
NB.   E - N-by-N matrix, matrix exponent exp(A*T)
NB.   K = N + C, where C is quantity of complex eigenvalues
NB.   N >= 0
NB.
NB. Notes:
NB.   Matrix A need not to be invertible
NB.
NB. Reference:
NB.   008_Theory_Inf_Proc_Syst_Ch4.pdf

expm=: 3 : 0
  'M P V T'=. y
  vmatrix_jlapack_ M                     NB. M is table
  'k n'=. $ M
  assert. k >: n
  assert. 3 = # $ P                      NB. Apw is report (3-rank array)
  assert. *./ n = $ P                    NB. all dimentions are equal to n
  assert. 1 = # $ V                      NB. V is vector
  assert. n = # V
  SUM(a[i](T)*A^i,i=0..n-1)
)

V=. 1 {:: zgeev_jlapack_ A               NB. eigenvalues(A)

NB. =========================================================
NB. GENERAL DATA FLOW:
NB. vm verb vlambda
NB. where vm      - вектор кратностей mi и mj, соответствующих
NB.                 собственным значениям из vlambda
NB.       vlambda - вектор уникальных собственных значений без
NB.                 учёта комплексно-сопряжённых
NB. following holds:
NB.   (+/ vm) = k
NB.   (# vm) = (# vlambda) = r-C
NB. where k - matrix A minimal polynom's order
NB.       r - quantity of unique eigenvalues
NB.       C - quantity of unique complex eigenvalues without self-adjoiners
NB.
NB. TODO
NB.   - отфильтровывать из M нулевые Mi, соответствующие действительным labmda

NB. ---------------------------------------------------------
NB. prepV
NB. Prepare eigenvalues: remove dups and self-adjoiners, count.
NB. Outputs 3 columns: eigenvalue , multiplicity , minimal polynom's order
NB.
NB. Example:
NB.    prepV 1 1 2 3j3 3j_3 4j4 4j_4 4j4 4j_4
NB.   1 2 9
NB.   2 1 9
NB. 3j3 2 9
NB. 4j4 4 9

prepV=: (~. ,. (cnt * mul)) @ nnegim ,. #
cnt=: 1: #. =               NB. count atoms
mul=: (>: @ (0 < im) @ ~.)  NB. multipliers vector: 1 for real, 2 for complex
nnegim=: ] #~ 0 <: im       NB. filter out atoms with negative imaginary part
im=: 11 o. ]                NB. take imaginary part

NB. ---------------------------------------------------------
NB. Gi=. makeGi lambdai , mi , k
NB.    makeGi 1.1 3 5
NB. 1 1 1 1  1
NB. 0 1 2 3  4
NB. 0 0 2 6 12

makeGi=: (xIOx makeRji"0/ xIOy)"1
makeRji=: ! * ! @ [                      NB. (!y)%(!y-x)
xIOx=: xIO @ (1: { ])
xIOy=: xIO @ (2: { ])
xIO=: i. @ x:

NB. ---------------------------------------------------------
NB. T1i=. k make_T1i lambda_powers
NB.    8 make_T1i 1.11 2.22 3.33 4.44 5.55 6.66 7.77 8.88
NB. 1.11 2.22 3.33 4.44 5.55 6.66 7.77 8.88
NB.    0 1.11 2.22 3.33 4.44 5.55 6.66 7.77
NB.    0    0 1.11 2.22 3.33 4.44 5.55 6.66
NB.    0    0    0 1.11 2.22 3.33 4.44 5.55
NB.    0    0    0    0 1.11 2.22 3.33 4.44
NB.    0    0    0    0    0 1.11 2.22 3.33
NB.    0    0    0    0    0    0 1.11 2.22
NB.    0    0    0    0    0    0    0 1.11
makeT1i=: nIOx shrybyx ]
nIOx=: - @ i. @ [
shrybyx=: (|.!.0)"0 1                  NB. shift y to right by x

NB. lambda_powers=. k gen_ps lambda
NB.    10 gen_ps 2
NB. 1 2 4 8 16 32 64 128 256 512
gen_ps=: (^ i.)~

make_R=: */ 
make_M
refine_M
gen_M
