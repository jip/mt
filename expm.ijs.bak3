NB. expm.ijs
NB. Calculate matrix exponent and its integral
NB. 
NB. prexpm  pre-calculate time-invariant parts for expm
NB. expm    calculate matrix exponent via Lagrange-Sylvester
NB.         interpolation polynome
NB.
NB. 2008-01-10 1.0.0 Igor Zhuravlov

NB. ===========================================================================
NB. pexpm
NB. Pre-calculate time-invariant parts for expm and iexpm
NB.
NB. Usage:
NB.   'M P V'=. pexpm A
NB. where:
NB.   A - N-by-N state matrix of LTI system from SS representation
NB.   M - K-by-N matrix for equation M*A(t)=L(t)
NB.   P - N-by-N-by-N matrix, powers 0..(N-1) of A
NB.   V - N-vector, eigenvalies of A


NB. ---------------------------------------------------------
NB. expm
NB. Calculate matrix exponent exp(A*T) of matrix A for discretizing period T
NB. via Lagrange-Sylvester interpolation polynome
NB.
NB. Usage:
NB.   E=. expm M;P;V;T
NB. where:
NB.   M - K-by-N matrix for equation M*A(t)=L(t)
NB.   P - N-by-N-by-N matrix, powers 0..(N-1) of A
NB.   V - N-vector, eigenvalies of A
NB.   T - sampling period, T>0
NB.   E - N-by-N matrix, matrix exponent exp(A*T)
NB.   K = N + C, where C is quantity of complex eigenvalues
NB.   N >= 0
NB.
NB. Notes:
NB.   Matrix A need not to be invertible
NB.
NB. Reference:
NB.   008_Theory_Inf_Proc_Syst_Ch4.pdf

expm=: 3 : 0
  'M P V T'=. y
  vmatrix_jlapack_ M                     NB. M is table
  'k n'=. $ M
  assert. k >: n
  assert. 3 = # $ P                      NB. Apw is report (3-rank array)
  assert. *./ n = $ P                    NB. all dimentions are equal to n
  assert. 1 = # $ V                      NB. V is vector
  assert. n = # V
  NB.SUM(a[i](T)*A^i,i=0..n-1)
)

NB. ===========================================================================
NB. M=. makeM prepared_eigenvalues
NB.    x: makeM prepV 1 1 2 3j3 3j_3 4j4 4j_4 4j4 4j_4
NB. 1 1  1    1     1     1      1       1        1
NB. 0 1  2    3     4     5      6       7        8
NB. 1 2  4    8    16    32     64     128      256
NB. 1 3  0  _54  _324  _972      0   17496   104976
NB. 0 1  6    0  _216 _1620  _5832       0   139968
NB. 0 3 18   54     0  _972  _5832  _17496        0
NB. 0 0  6   54   216     0  _5832  _40824  _139968
NB. 1 4  0 _128 _1024 _4096      0  131072  1048576
NB. 0 1  8    0  _512 _5120 _24576       0  1048576
NB. 0 0  2   24     0 _2560 _30720 _172032        0
NB. 0 0  0    6    96     0 _15360 _215040 _1376256
NB. 0 4 32  128     0 _4096 _32768 _131072        0
NB. 0 0  8   96   512     0 _24576 _229376 _1048576
NB. 0 0  0   24   384  2560      0 _172032 _1835008
NB. 0 0  0    0    96  1920  15360       0 _1376256
NB.
NB. TODO
NB. - avoid boxing via direct append

makeM=: ; @: dropaces @: , @: (<"2 @: makeMi " 1)
makeMi=: makeGi *"2 makeTi`makeT23i @. getic  NB. make Mi
makeT23i=: reim @: makeTi                      NB. split Ti on T2i and T3i
dropaces=: #~ (a: ~: ])                        NB. exclude empty cells
reim=: 9 11 o."0 2 ]                           NB. separate real and imagine parts

NB. ---------------------------------------------------------
NB. Gi=. makeGi lambdai , mi , ic , k
NB.    makeGi 1j1 3 1 5
NB. 1 1 1 1  1
NB. 0 1 2 3  4
NB. 0 0 2 6 12

makeGi=: (xIOmi makeRji"0/ xIOk)"1
makeRji=: ! * ! @ [    NB. (!y)%(!y-x)
xIOmi=: xIO @ getmi    NB. i. x: mi
xIOk=: xIO @ getk      NB. i. x: k
xIO=: i. @ x:

NB. ---------------------------------------------------------
NB. T1i=. makeTi lambdai , mi , ic , k
NB. 'T2i T3i'=. reim makeTi lambdai , mi , k
NB.    makeTi 1.1 3 0 5
NB. 1 1.1 1.21 1.331 1.4641
NB. 0   1  1.1  1.21  1.331
NB. 0   0    1   1.1   1.21
NB.    makeTi 1j1 3 1 5
NB. 1 1j1 0j2 _2j2   _4
NB. 0   1 1j1  0j2 _2j2
NB. 0   0   1  1j1  0j2

makeTi=: IOnmi shrybyx lipows  NB. form mi-by-k table from vector's shifts
IOnmi=: - @ i. @ getmi         NB. 0 _1 _2 ... -(mi-1)
shrybyx=: (|.!.0)"0 1          NB. shift y to right by x
lipows=: getli (^ i.) getk     NB. lambdai ^ i. k

NB. ---------------------------------------------------------
NB. prepV
NB. Prepare eigenvalues: remove dups and self-adjoiners,
NB. classify and count. Outputs 4 columns:
NB. - eigenvalue
NB. - multiplicity, taking self-adjoiners into account
NB. - datatype flag: 0 for real, 1 for complex
NB. - minimal polynom's order
NB.
NB. If:
NB.       'vlambda vm ic vk' =. |: prepV eigenvalues_of_A
NB. then
NB.       vk -: (# vm) $ k
NB.       (+/ vm) = k
NB.       (# vm) = (# vlambda) = (r - C)
NB.       ic -: ((0 ~: im) vlambda)
NB. where k - matrix A minimal polynom's order
NB.       r - quantity of unique eigenvalues
NB.       C - quantity of unique complex eigenvalues without
NB.           self-adjoiners
NB.
NB. Example:
NB.    prepV 1 1 2 3j3 3j_3 4j4 4j_4 4j4 4j_4
NB.   1 2 0 9
NB.   2 1 0 9
NB. 3j3 2 1 9
NB. 4j4 4 1 9

prepV=: (~. ,. (cnt ((* >:) ,. ]) ic)) @ nnegim ,. #
nnegim=: ] #~ 0 <: im  NB. filter out atoms with negative imaginary part
im=: 11 o. ]           NB. take imaginary part
ic=: (0 < im) @ ~.     NB. datatype flag
cnt=: 1: #. =          NB. count atoms

NB. ---------------------------------------------------------
NB. Utilities

getli=: 0: { ]         NB. get lambdai
getmi=: 1: { ]         NB. get mi
getic=: 2: { ]         NB. get ic
getk=: 3: { ]          NB. get k

NB.V=. 1 {:: zgeev_jlapack_ A               NB. eigenvalues(A)
