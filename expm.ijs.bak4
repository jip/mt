NB. expm.ijs
NB. Calculate matrix exponent and its integral
NB. 
NB. prexpm  pre-calculate time-invariant parts for expm
NB. expm    calculate matrix exponent via Lagrange-Sylvester
NB.         interpolation polynome
NB.
NB. References:
NB. [1]  008_Theory_Inf_Proc_Syst_Ch4.pdf
NB. [2]  Andrievskij B.R., Fradkov A.L. Izbrannye glavy teorii avtomaticheskogo upravlenija (SPb, Nauka, 2000)(ru)(470s)
NB.
NB. Resources:
NB. - www.jsoftware.com/jwiki/...
NB. - www.dvgu.ru/forum/...
NB.
NB. 2008-01-10 1.0.0 Igor Zhuravlov

require '~user/projects/jlapack/lapack.ijs'     NB. '~addons/math/lapack/lapack.ijs'
require '~user/projects/jlapack/dgeev.ijs'      NB. -//-
NB. require '~user/projects/jlapack/dgesvx.ijs'     NB. -//-

NB. ===========================================================================
NB. pexpm
NB. Pre-calculate time-invariant parts for expm
NB.
NB. Usage:
NB.   'M P V'=. MPV=. pexpm A
NB. where:
NB.   A - N-by-N state matrix of LTI system from SS representation
NB.   M - K-by-N matrix for equation M*A(t)=L(t)
NB.   P - N-by-N-by-N matrix, powers 0..(N-1) of A
NB.   V - ?-by-4 matrix, output of prepV
NB.   K = N + C, where C is quantity of complex eigenvalues
NB.   N >= 0
NB.
NB. Notes:
NB.   Matrix A need not to be invertible

pexpm=: (0 & makeLM @: prepV @: dgeevV_jlapack_) ; Apows ; prepV

NB. ---------------------------------------------------------
NB. expm
NB. Calculate matrix exponent exp(A*T) of matrix A for discretizing period T
NB. via Lagrange-Sylvester interpolation polynome
NB.
NB. Usage:
NB.   E=. MPV expm T
NB. where:
NB.   MPV - output of pexpm (M;P;V)
NB.   T   - sampling period, T>0
NB.   E   - N-by-N matrix, matrix exponent exp(A*T)
NB.   N >= 0

expm=: +/ @: (getP * makeAt)

NB. ===========================================================================
NB. At=. MPV makeAt T

makeAt=: dgesvx_jlapack_ @: (getM ; ] makeLM getV)

NB. ---------------------------------------------------------
NB. Lt=. T makeLM prepared_eigenvalues
NB. M=. makeLM prepared_eigenvalues
NB.
NB. Test:
NB.    1.1 makeLM prepV 4 4 3 2j2 2j_2 1j1 1j_1 1j1 1j_1
NB. 81.4509 89.596 27.1126 _5.31123 _5.84235 7.29669 8.02636 1.36268 1.49895 1.64884 1.81372 2.67733 2.94507 3.23958 3.56353
NB.    0 makeLM prepV 4 4 3 2j2 2j_2 1j1 1j_1 1j1 1j_1
NB. 1 4 16  64 256 1024 4096 16384  65536
NB. 0 1  8  48 256 1280 6144 28672 131072
NB. 1 3  9  27  81  243  729  2187   6561
NB. 1 2  0 _16 _64 _128    0  1024   4096
NB. 0 1  4   0 _64 _320 _768     0   8192
NB. 0 2  8  16   0 _128 _512 _1024      0
NB. 0 0  4  24  64    0 _768 _3584  _8192
NB. 1 1  0  _2  _4   _4    0     8     16
NB. 0 1  2   0  _8  _20  _24     0     64
NB. 0 0  2   6   0  _40 _120  _168      0
NB. 0 0  0   6  24    0 _240  _840  _1344
NB. 0 1  2   2   0   _4   _8    _8      0
NB. 0 0  2   6   8    0  _24   _56    _64
NB. 0 0  0   6  24   40    0  _168   _448
NB. 0 0  0   0  24  120  240     0  _1344
NB.
NB. TODO:
NB. - avoid boxing via direct append

makeLM=: ; @: (< @: makeLMi " 1)    NB. make and merge all Li or Mi
makeLMi=: getic (c2r ^: [) prepLMi  NB. complete Li or Mi, realificate if required
prepLMi=: prepLi`prepMi @. (0 = [)  NB. choose Li or Mi to prepare
prepLi=: (^ @ ([ * getli)) * Tpows  NB. prepare Li
prepMi=: makeGi * makeTi            NB. prepare Mi=. Gi*Ti
Tpows=: [ (^ i.) getmi              NB. T ^ i. mi

NB. ---------------------------------------------------------
NB. Gi=. makeGi lambdai , mi , ic , k
NB.    makeGi 4j4 4 1 9
NB. 1 1 1 1  1  1   1   1   1
NB. 0 1 2 3  4  5   6   7   8
NB. 0 0 2 6 12 20  30  42  56
NB. 0 0 0 6 24 60 120 210 336

makeGi=: (xIOmi makeRji"0/ xIOk)"1
makeRji=: ! * ! @ [    NB. (!y)%(!y-x)
xIOmi=: xIO @ getmi    NB. i. x: mi
xIOk=: xIO @ getk      NB. i. x: k
xIO=: i. @ x:

NB. ---------------------------------------------------------
NB. T1i=. makeTi lambdai , mi , ic , k
NB. 'T2i T3i'=. reim makeTi lambdai , mi , k
NB.    makeTi 4 2 0 9
NB. 1 4 16 64 256 1024 4096 16384 65536
NB. 0 1  4 16  64  256 1024  4096 16384
NB.    x: reim makeTi 1j1 4 1 9
NB. 1 1 0 _2 _4 _4  0  8 16
NB. 0 1 1  0 _2 _4 _4  0  8
NB. 0 0 1  1  0 _2 _4 _4  0
NB. 0 0 0  1  1  0 _2 _4 _4
NB.
NB. 0 1 2  2  0 _4 _8 _8  0
NB. 0 0 1  2  2  0 _4 _8 _8
NB. 0 0 0  1  2  2  0 _4 _8
NB. 0 0 0  0  1  2  2  0 _4

makeTi=: IOnmi shrybyx lipows  NB. form mi-by-k table from vector's shifts
IOnmi=: - @ i. @ getmi         NB. 0 _1 _2 ... -(mi-1)
shrybyx=: (|.!.0)"0 1          NB. shift y to right by x
lipows=: getli (^ i.) getk     NB. lambdai ^ i. k

NB. ---------------------------------------------------------
NB. prepV
NB. Prepare eigenvalues: remove dups and self-adjoiners,
NB. classify and count. Outputs 4 columns:
NB. - eigenvalue
NB. - multiplicity, taking self-adjoiners into account
NB. - datatype flag: 0 for real, 1 for complex
NB. - minimal polynom's order
NB.
NB. If:
NB.       'vlambda vm ic vk' =. |: prepV eigenvalues_of_A
NB. then
NB.       vk -: (# vm) $ k
NB.       (+/ vm) = k
NB.       (# vm) = (# vlambda) = (r - C)
NB.       ic -: ((0 ~: im) vlambda)
NB. where k - matrix A minimal polynom's order
NB.       r - quantity of unique eigenvalues
NB.       C - quantity of unique complex eigenvalues without
NB.           self-adjoiners
NB.
NB. Example:
NB.    prepV 4 4 3 2j2 2j_2 1j1 1j_1 1j1 1j_1
NB.   4 2 0 9
NB.   3 1 0 9
NB. 2j2 2 1 9
NB. 1j1 4 1 9

prepV=: (~. ,. (cnt ((* >:) ,. ]) ic)) @ nnegim ,. #
nnegim=: ] #~ 0 <: im  NB. filter out atoms with negative imaginary part
im=: 11 o. ]           NB. take imaginary part
ic=: (0 < im) @ ~.     NB. datatype flag
cnt=: 1: #. =          NB. count atoms

NB. ---------------------------------------------------------
NB. Utilities

getM=: 0: {:: [              NB. get M
getP=: 1: {:: [              NB. get P
getV=: 2: {:: [              NB. get V
getli=: 0: { ]               NB. get lambdai
getmi=: 1: { ]               NB. get mi
getic=: 2: { ]               NB. get ic
getk=: 3: { ]                NB. get k
c2r=: ,/ @: (9 11 o."0 _ ])  NB. realificate complex y
