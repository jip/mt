NB. expm.ijs
NB. Calculate matrix exponent and Cauchy integral
NB. 
NB. prexpm  prepare time-invariant parts for expm
NB. expm    calculate matrix exponent and Cauchy integral
NB.
NB. References:
NB. - Podchukaev V.A. Theory of informational processes and systems. - M.,
NB.   2006. (Подчукаев В. А. Теория информационных процессов и систем. -
NB.   М.: Гардарики, 2006 - 209 с.)
NB. - Andrievskiy B.R., Fradkov A.L. Selected chapters of automatic
NB.   control theory with MATLAB examples. - SPb., 2000 (Андриевский Б.
NB.   Р., Фрадков А. Л. Избранные главы теории автоматического управления
NB.   с примерами на языке MATLAB. - СПб.: Наука, 2000. - 475 с., ил. 86)
NB.
NB. Resources:
NB. - http://www.jsoftware.com/jwiki/...
NB. - http://www.dvgu.ru/forum/...
NB.
NB. TODO:
NB. - consider s/@:/@/g when possible
NB. - consider complex A or B => non-self-adjoined eigenvalues
NB. - consider B is vector
NB.
NB. 2008-01-11 1.0.0 Igor Zhuravlov

require '~addons/math/lapack/lapack.ijs'
NB. require '~user/projects/jlapack/geev.ijs'       NB. '~addons/math/lapack/geev.ijs'
NB. require '~user/projects/jlapack/gesvx.ijs'      NB. '~addons/math/lapack/gesvx.ijs'

coclass 'tau'

NB. ===========================================================================
NB. prexpm
NB. Prepare time-invariant parts for expm
NB.
NB. Syntax:
NB.   'M V P Nx'=. MVPN=. prexpm A;B
NB. where:
NB.   A - Nx-by-Nx state matrix of LTI system
NB.   B - Nx-by-Nu control input matrix of LTI system
NB.   M - Nm-by-Ng matrix for equation M*A(t)=L(t), output of makeLtM
NB.   V - (#vm)-by-5 matrix, prepared eigenvalues of G, output of prepV
NB.   P - Ng-by-Ng-by-Ng matrix, powers 0..(Ng-1) of G, output of makeP
NB.   G - Ng-by-Ng matrix, augmented LTI system, output of makeG
NB.   Nm = +/ vm * (ic+1), see prepV
NB.   Ng = Nx + Nu
NB.   Nx >= 0
NB.   Nu >= 0
NB.
NB. TODO:
NB. - test

prexpm=: (((0 & makeLtM ; ]) @ prepV @ geevV_jlapack_) ; makeP) @ makeG ; getCols @ getA

NB. ---------------------------------------------------------
NB. expm
NB. Calculate matrix exponent
NB.   exp(A*T)
NB. and Cauchy integral
NB.   Integral(exp(A*(T-t))*dt,t=0..T)*B
NB. for sampling period T via Lagrange-Sylvester interpolation
NB. polynome
NB.
NB. Syntax:
NB.   'EA IE'=. MVPN expm T
NB. where:
NB.   MVPN - output of prexpm, being (M;V;P;Nx)
NB.   T    - sampling period, T>0
NB.   EA   - Nx-by-Nx matrix, matrix exponent
NB.   IE   - Nx-by-Nu matrix, Cauchy intergal
NB.   Nu   = (#P)-Nx
NB.
NB. TODO:
NB. - test

expm=: getNx extract augsys
augsys=: +/ @ (getP * makeAt)  NB. find exponent of augmented system
extract=: [ splitbyx {.        NB. extract 1st x rows from table y
splitbyx=: {."1 ; }."1         NB. split table y at column x

NB. ===========================================================================
NB. makeG
NB. Build G matrix of augmented LTI system: G = ( A  B ) Nx
NB.                                             ( 0  0 ) Nu
NB.                                               Nx Nu
NB. Syntax: G=: makeG A;B

makeG=: getA ((+ & getCols) {. ,.) getB

NB. ---------------------------------------------------------
NB. makeP
NB. Make report of G powers
NB.
NB. Syntax: 
NB.   P=. makeP G
NB. where
NB.   G - Ng-by-Ng matrix, augmented LTI system, output of makeG
NB.   P - Ng-by-Ng-by-Ng matrix, powers 0..(Ng-1) of G
NB.
NB. Test:
NB.    makeP ? 3 3 $ 10
NB.  1   0  0
NB.  0   1  0
NB.  0   0  1
NB.
NB.  6   5  9
NB.  2   4  9
NB.  0   7  0
NB.
NB. 46 113 99
NB. 20  89 54
NB. 14  28 63
NB.
NB. Notes:
NB. - powers are calculated via repeated squaring to
NB.   reduce operations from O(Ng*Ng) to O(Ng*log Ng), see
NB.   http://www.jsoftware.com/jwiki/Essays/Linear_Recurrences
NB. - 0-th power (identity matrix) is substituted directly
NB.   without calculation

makeP=: # repl0 <               NB. call: (#G) repl0 (<G)
repl0=: (idmat @ [)`0:`prepP }  NB. replace 0-th element in y by identity matrix of size x
prepP=: (pows @ [) topows ]     NB. form boxed list of y ^ i. x
topows=: > @ (topow &. >)       NB. apply dyad topow under boxes, then open
topow=: mp/ @ (mp~ @ ] ^: [)    NB. produce table y to powers from list x, then product all
pows=: p2b"1 @ #: @ i.          NB. call p2b for each power y represented binary
p2b=: < @ I. @ |.               NB. cvt bits of y to powers, then box it

NB. ---------------------------------------------------------
NB. makeLtM
NB. Calculate matrix M or vector L(t) for equation M*A(t)=L(t)
NB.
NB. Syntax:
NB.   Lt=. T makeLtM V
NB.   M=. 0 makeLtM V
NB. where:
NB.   V  - (#vm)-by-5 matrix, prepared eigenvalues of G, output of prepV
NB.   T  - sampling period, T>0
NB.   M  - Nm-by-Ng matrix for equation M*A(t)=L(t)
NB.   Lt - Nm-vector, RHS L(t) for equation M*A(t)=L(t)
NB.   Nm = +/ vm * (ic+1), see prepV
NB.   Ng = #G
NB.
NB. Test:
NB.    1.1 makeLtM prepV 4 4 3 2j2 2j_2 1j1 1j_1 1j1 1j_1
NB. 81.4509 89.596 27.1126 _5.31123 _5.84235 7.29669 8.02636 1.36268 1.49895 1.64884 1.81372 2.67733 2.94507 3.23958 3.56353
NB.    0 makeLtM prepV 4 4 3 2j2 2j_2 1j1 1j_1 1j1 1j_1
NB. 1 4 16  64 256 1024 4096 16384  65536
NB. 0 1  8  48 256 1280 6144 28672 131072
NB. 1 3  9  27  81  243  729  2187   6561
NB. 1 2  0 _16 _64 _128    0  1024   4096
NB. 0 1  4   0 _64 _320 _768     0   8192
NB. 0 2  8  16   0 _128 _512 _1024      0
NB. 0 0  4  24  64    0 _768 _3584  _8192
NB. 1 1  0  _2  _4   _4    0     8     16
NB. 0 1  2   0  _8  _20  _24     0     64
NB. 0 0  2   6   0  _40 _120  _168      0
NB. 0 0  0   6  24    0 _240  _840  _1344
NB. 0 1  2   2   0   _4   _8    _8      0
NB. 0 0  2   6   8    0  _24   _56    _64
NB. 0 0  0   6  24   40    0  _168   _448
NB. 0 0  0   0  24  120  240     0  _1344

makeLtM=: ; @: (< @: makeLtMi " 1)    NB. make and merge all L[i](t) or M[i]
makeLtMi=: getic (c2r ^: [) prepLtMi  NB. complete L[i](t) or M[i], realificate if required
prepLtMi=: prepLti`prepMi @. (0 = [)  NB. choose L[i](t) or M[i] to prepare
prepLti=: (^ @ ([ * getli)) * Tpows   NB. prepare L[i](t)
prepMi=: makeGi * makeTi              NB. prepare Mi=. Gi*Ti
Tpows=: [ (^ i.) getmi                NB. T ^ i. mi

NB. ---------------------------------------------------------
NB. makeAt
NB. Solve equation M*A(t)=L(t) for A(t)
NB.
NB. Syntax:
NB.   At=. MVPN makeAt T
NB. where:
NB.   T    - sampling period, T>0
NB.   MVPN - output of prexpm, being (M;V;P;Nx)
NB.   At   - Nm-vector, solution A(t) of equation M*A(t)=L(t)
NB.   Nm = +/ vm * (ic+1), see prepV
NB.
NB. TODO:
NB. - test

makeAt=: gesvx_jlapack_ @: (getM ; ] makeLtM getV)

NB. ---------------------------------------------------------
NB. makeGi
NB. Calculate G[i] for M[i]
NB.
NB. Syntax:
NB.   Gi=. makeGi lambdai , ic , mi , IOs , Nm , k
NB. where:
NB.   k       - matrix G minimal polynom's order, k = Ng
NB.   Nm      = # M
NB.   IOs     - IO 1st row (atom) of corresp. Mi (Li) in M (Lt)
NB.   mi      - multiplicity, taking self-adjoiners into account
NB.   ic      - datatype flag: 0 for real, 1 for complex
NB.   lambdai - i-th eigenvalue of G
NB.   Gi      - mi-by-k matrix, G[i]
NB.   
NB. Test:
NB.    makeGi 1j1 1 4 7 15 9
NB. 1 1 1 1  1  1   1   1   1
NB. 0 1 2 3  4  5   6   7   8
NB. 0 0 2 6 12 20  30  42  56
NB. 0 0 0 6 24 60 120 210 336

makeGi=: xIOmi makeRji/ xIOk  NB. call (mi makeRji k) for each pair (mi,k)
makeRji=: (! * ! @ [)"0       NB. (!y)%(!y-x)
xIOmi=: xIO @ getmi           NB. i. x: mi
xIOk=: xIO @ getk             NB. i. x: k
xIO=: i. @ x:

NB. ---------------------------------------------------------
NB. makeTi
NB. Calculate T1[i] or T2[i] and T3[i] for M[i]
NB.
NB. Syntax:
NB.   T1i=. makeTi lambdai , ic , mi , IOs , Nm , k
NB.   'T2i T3i'=. reim makeTi lambdai , ic , mi , IOs , Nm , k
NB. where:
NB.   k           - matrix G minimal polynom's order, k = Ng
NB.   Nm          = # M
NB.   IOs         - IO 1st row (atom) of corresp. Mi (Li) in M (Lt)
NB.   mi          - multiplicity, taking self-adjoiners into account
NB.   ic          - datatype flag: 0 for real, 1 for complex
NB.   lambdai     - i-th eigenvalue of G
NB.   T1i,T2i,T3i - mi-by-k matrix, T1[i], T2[i] or T3[i] respectively
NB.   
NB. Tests:
NB.    makeTi 4 0 2 0 15 9
NB. 1 4 16 64 256 1024 4096 16384 65536
NB. 0 1  4 16  64  256 1024  4096 16384
NB.
NB.    x: (9 11 o."0 _ ]) makeTi_tau_ 1j1 1 4 7 15 9
NB. 1 1 0 _2 _4 _4  0  8 16
NB. 0 1 1  0 _2 _4 _4  0  8
NB. 0 0 1  1  0 _2 _4 _4  0
NB. 0 0 0  1  1  0 _2 _4 _4
NB.
NB. 0 1 2  2  0 _4 _8 _8  0
NB. 0 0 1  2  2  0 _4 _8 _8
NB. 0 0 0  1  2  2  0 _4 _8
NB. 0 0 0  0  1  2  2  0 _4

makeTi=: IOnmi shybyx lipows  NB. form mi-by-k table from vector's shifts
IOnmi=: - @ i. @ getmi        NB. 0 _1 _2 ... -(mi-1)
lipows=: getli (^ i.) getk    NB. lambdai ^ i. k

NB. ---------------------------------------------------------
NB. prepV
NB. Prepare eigenvalues: remove dups and self-adjoiners,
NB. classify and count. Outputs 5 columns:
NB. - lambdai, eigenvalue
NB. - ic, datatype flag: 0 for real, 1 for complex
NB. - mi, multiplicity, taking self-adjoiners into account
NB. - IOs, IO 1st row (atom) of corresp. Mi (Li) in M (Lt)
NB. - Nm = # M
NB. - k, matrix G minimal polynom's order, k = Ng
NB.
NB. If:
NB.       'vlambda vic vm vIOs vNm vk' =. |: prepV eigenvalues_of_G
NB. then
NB.       vk -: (# vm) $ k
NB.       vNm -: (# vm) $ Nm
NB.       (+/ vm) = k
NB.       (# vm) = (# vlambda) = (r - C)
NB.       ic -: ((0 ~: im) vlambda)
NB. where r - quantity of unique eigenvalues
NB.       C - quantity of unique complex eigenvalues without
NB.           self-adjoiners
NB.
NB. Test:
NB.    prepV 4 4 3 2j2 2j_2 1j1 1j_1 1j1 1j_1   NB. r=6, C=2
NB.   4 0 2 0 15 9
NB.   3 0 1 2 15 9
NB. 2j2 1 2 3 15 9
NB. 1j1 1 4 7 15 9

prepV=: (~. ,. (cnt (] ,. ([ (* ([ ,. (IOs ,. (+/ @: *))) ]) (>: @ ]))) ic)) @ nnegim ,. #
nnegim=: ] #~ 0 <: im           NB. filter out atoms with negative imaginary part
im=: 11 o. ]                    NB. take imaginary part
ic=: (0 < im) @ ~.              NB. datatype flag
IOs=: _1 & shybyx @ (+/\) @: *  NB. IO 1st row (atom) of corresponding M[i] (L[i](t)) in M (L(t))
cnt=: 1: #. =                   NB. count atoms

NB. ---------------------------------------------------------
NB. Utilities

getA=: 0 {:: ]               NB. extract A
getB=: 1 {:: ]               NB. extract B

getM=: 0 {:: [               NB. extract M
getV=: 1 {:: [               NB. extract V
getP=: 2 {:: [               NB. extract P
getNx=: 3 {:: [              NB. extract Nx

getli=: 0 { ]                NB. extract lambdai
getic=: 1 { ]                NB. extract ic
getmi=: 2 { ]                NB. extract mi
getIOs=: 3 { ]               NB. extract IOs
getNm=: 4 { ]                NB. extract Nm
getk=: 5 { ]                 NB. extract k

getCols=: {: @ $             NB. get columns of table y
c2r=: ,/ @: (9 11 o."0 _ ])  NB. realificate complex y
idmat=: =@i.                 NB. identity matrix of size y
mp=: +/ .*                   NB. matrix product of x and y
shybyx=: (|.!.0)"0 1         NB. shift y with step x
